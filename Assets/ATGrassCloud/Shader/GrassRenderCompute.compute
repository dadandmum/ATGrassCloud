#pragma kernel CS_CalculatePosition

#include "Lib/HeightMapLib.hlsl"
#include "Lib/GrassLib.hlsl"
// #include "Lib/Simplex.compute"


float _TileSize;
int _InstancePerTile;
float _DrawDistance;
float _SnapDistance;
float _FullDensityDistance;
float4 _HeightMapData; // (centerPos.x , centerPos.y , size , 1.0f / size )

int2 _TileStartIndex;
int2 _TileNum;
float3 _CameraPosition;
float2 _CenterPosition;
float3 _BoundsMin;
float3 _BoundsMax;
float4 _Range; // ( InnerRange , OutterRange , 1.0 / innerRangeFade, 1.0 /  OutterRangeFade)

float4x4 _ViewProjectMatrix;

SamplerState sampler_Linear_Clamp; 
SamplerState sampler_Point_Clamp;

//Generated and passedby the Custom Renderer Feature
Texture2D<float2> _HeightMapRT;
Texture2D<float4> _GrassMaskMapRT;
//--------------------------------------------------

AppendStructuredBuffer<float3> _GrassPositions;
AppendStructuredBuffer<GrassData> _GrassOutput;

uint grc_murmurHash3(int input)
{
    uint h = abs(input);
    h ^= h >> 16;
    h *= 0x85ebca6b;
    h ^= h >> 13;
    h *= 0xc2b2ae3d;
    h ^= h >> 16;
    return h;
}

float grc_random(int index)
{
    return grc_murmurHash3(index) / 4294967295.0;
}

float Remap(float In, float2 InMinMax, float2 OutMinMax)
{
    return OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
}

// get position offset in X and Z direction
// tileIndex is the global index of the tile
// index is the instance index in the tile
float2 GetOffsetInTileXZ( int2 tileIndex , int index )
{
    // return float2(snoise(float3(tileIndex, index)), snoise(float3(index, tileIndex)));
    return (float2(grc_random(tileIndex.x * 5542 + tileIndex.y * 2984 + index * 89 ), grc_random(tileIndex.y * 9824 + tileIndex.x * 19 + index * 236 )) * 2 - 1) * _TileSize;
}

uint FrustumCulling(float4 absPosCS )
{
    if (absPosCS.z <= absPosCS.w && absPosCS.y <= absPosCS.w * 1.5 && absPosCS.x <= absPosCS.w * 1.1 && absPosCS.w <= _DrawDistance)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

float InOutEaseCubic( float x )
{
    return x * x * ( 3.0 - 2.0 * x );
}

uint DistanceCulling(float3 worldPos , int2 tileIndex, int index )
{
    // Get the world position of current grass instance
    // Get the world position of main camera
    // Calculate the distance between two positions
    // Cull if distance exeeds the threshold
    
    float d = distance(worldPos, _CameraPosition);
    float innerRange = _Range.x;
    float outterRange = _Range.y;
    float innerRangeFadeInv = _Range.z;
    float innerRangeX = InOutEaseCubic(saturate( 1.0 - ( innerRange - d ) * innerRangeFadeInv));
    float outterRangeFade = _Range.w;
    float outterRangeX = InOutEaseCubic(saturate( 1.0 - ( d - outterRange ) * outterRangeFade));
    
    if ( d <= outterRange && d >= innerRange)
    {
        return 1;
    } 
    else if ( d < innerRange && innerRangeX > 0 )
    {
        
        float rand = grc_random(tileIndex.x * 5542 + tileIndex.y * 29 + index * 8);
        return rand < innerRangeX;
    }
    else if ( d > outterRange && outterRangeX > 0 )
    {
        float rand = grc_random(tileIndex.x * 5542 + tileIndex.y * 29 + index * 8);
        return rand < outterRangeX;
    }
    else
    {
        return 0;
    }
}


[numthreads(8, 8, 1)]
void CS_CalculatePosition(uint3 id : SV_DispatchThreadID)
{

    // Index of the Tile in golbal scale 
    // we will generate one position in each tile
    int2 currentIndex = _TileStartIndex + id.xy; 

    // Transform to World position
    float2 positionXZ = currentIndex * _TileSize; 

    for ( int index = 0; index < _InstancePerTile; index++)
    {
        // Adding a small offset to it
        // Only one instance in a tile 
        float2 offset = GetOffsetInTileXZ(currentIndex, index);
        // positionXZ += (float2(random(currentIndex.x * 5542 + currentIndex.y), random(currentIndex.y * 9824 + currentIndex.x)) * 2 - 1) * _TileSize;
        float2 positionIndexXZ = positionXZ + offset;

        float2 uv = (positionIndexXZ - _HeightMapData.xy ) * _HeightMapData.w ;
        uv = uv * 0.5 + 0.5;

        float2 heightMap = _HeightMapRT.SampleLevel(sampler_Linear_Clamp, uv, 0).rg; //Sampling the HeightMap Texture (Red Channel: Height, Green Channel: Area where grass should be spawned)
        
        float positionY = DecodeHeight(heightMap.r, float2(_BoundsMin.y, _BoundsMax.y));
        // float positionY = Remap(heightMap.r, float2(0, 1), float2(_BoundsMin.y, _BoundsMax.y)); //Reconstruct the Y position from the Height Map
	
        float3 positionWS = float3(positionIndexXZ.x, positionY, positionIndexXZ.y);


        float4 positionCS = abs(mul(_ViewProjectMatrix, float4(positionWS, 1.0)));


        uint distanceCulling = DistanceCulling(positionWS, currentIndex, index);
        uint frustumCulling = FrustumCulling(positionCS);
 
        if ( distanceCulling > 0 && frustumCulling > 0)
        {
            GrassData data;
            data.position = positionWS;
            data.windOffset = 0;
            data.rand0 = grc_murmurHash3(currentIndex.x * 138 + currentIndex.y * 1824 + index * 7347);
            _GrassOutput.Append(data);
            
        }
    }
    
}